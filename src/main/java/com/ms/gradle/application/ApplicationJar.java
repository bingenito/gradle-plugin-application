/*
 * Morgan Stanley makes this available to you under the Apache License, Version 2.0 (the "License"). You may obtain a
 * copy of the License at http://www.apache.org/licenses/LICENSE-2.0. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

package com.ms.gradle.application;

import org.gradle.api.Action;
import org.gradle.api.artifacts.Configuration;
import org.gradle.api.artifacts.ModuleVersionIdentifier;
import org.gradle.api.artifacts.ResolvedArtifact;
import org.gradle.api.artifacts.ResolvedConfiguration;
import org.gradle.api.file.CopySpec;
import org.gradle.api.file.DuplicatesStrategy;
import org.gradle.api.file.FileCopyDetails;
import org.gradle.api.file.FileTree;
import org.gradle.api.file.RelativePath;
import org.gradle.api.java.archives.Attributes;
import org.gradle.api.java.archives.Manifest;
import org.gradle.api.java.archives.ManifestException;
import org.gradle.api.java.archives.ManifestMergeSpec;
import org.gradle.api.plugins.BasePlugin;
import org.gradle.api.plugins.JavaPluginConvention;
import org.gradle.api.provider.HasConfigurableValue;
import org.gradle.api.provider.MapProperty;
import org.gradle.api.provider.Property;
import org.gradle.api.provider.Provider;
import org.gradle.api.tasks.CacheableTask;
import org.gradle.api.tasks.Input;
import org.gradle.api.tasks.Nested;
import org.gradle.api.tasks.Optional;
import org.gradle.api.tasks.TaskCollection;
import org.gradle.api.tasks.bundling.Jar;

import java.io.File;
import java.io.Serializable;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;

/**
 * Assembles an application JAR archive.
 */
@CacheableTask
public abstract class ApplicationJar extends Jar implements ApplicationSpec {

    /**
     * Name of the build directory where the application JARs will be generated by default.
     */
    public static final String APPLICATION_DIRECTORY_NAME = Application.APPLICATION;

    /**
     * Name of the subdirectory where the dependencies will be placed by default.
     */
    public static final String DEPENDENCY_DIRECTORY_NAME = "lib";

    /**
     * <p><b>IMPORTANT:</b> This is an {@link Optional} property, so wherever we query its value, we must specify a
     * {@link Provider#orElse} fallback.</p>
     * <p><b>IMPORTANT:</b> All properties of the raw {@link Jar} task that affect the behavior of this task must
     * somehow be exposed as an {@link Input} of {@link ApplicationJar}. Unfortunately, we can't simply expose the
     * {@link Jar} task in its entirety as an {@link Input}, because the {@link Jar} class is not {@link Serializable}.
     * Exposing it as {@link Nested} would also cause problems, as we would "inherit" the {@link Jar} task's outputs
     * too. The good news, however, is that anything that affects the {@link Jar} task's own output file
     * ({@link Jar#getArchiveFile}) is already implicitly exposed through our input file ({@link #getRawJar}).</p>
     *
     * @return The {@link #getRawJar rawJar} property presented as a provider that finalizes the underlying property
     * when queried.
     */
    @Nonnull
    private Provider<Jar> rawJar() {
        return withFinalizeValueOnRead(getRawJar());
    }

    /**
     * <p><b>IMPORTANT:</b> This is an {@link Optional} property, so wherever we query its value, we must specify a
     * {@link Provider#orElse} fallback.</p>
     *
     * @return The {@link #getDependencies dependencies} property presented as a provider that finalizes the underlying
     * property when queried.
     */
    @Nonnull
    private Provider<Configuration> dependencies() {
        return withFinalizeValueOnRead(getDependencies());
    }

    /**
     * <p><b>IMPORTANT:</b> Wherever we query the value of this property, we should add a no-op {@link Provider#orElse}
     * fallback, so that if the user leaves the property empty, Gradle can still reach the input validation step and
     * show them a clear and helpful error message.</p>
     *
     * @return The {@link #getDependencyDirectoryName dependencyDirectoryName} property presented as a provider that
     * finalizes the underlying property when queried.
     */
    @Nonnull
    private Provider<String> dependencyDirectoryName() {
        return withFinalizeValueOnRead(getDependencyDirectoryName());
    }

    /**
     * <p><b>IMPORTANT:</b> Wherever we query the value of this property, we should add a no-op {@link Provider#orElse}
     * fallback, so that if the user leaves the property empty, Gradle can still reach the input validation step and
     * show them a clear and helpful error message.</p>
     *
     * @return The {@link #getMainClass mainClass} property presented as a provider that finalizes the underlying
     * property when queried.
     */
    @Nonnull
    private Provider<String> mainClass() {
        return withFinalizeValueOnRead(getMainClass());
    }

    /**
     * <p><b>IMPORTANT:</b> Be careful not to query the value of this property too early, as doing so will prevent any
     * further changes to the underlying {@link Configuration}.</p>
     *
     * @return The {@link #resolvedDependencies} property presented as a provider that finalizes the underlying property
     * when queried.
     */
    @Nonnull
    private Provider<Map<File, Dependency>> resolvedDependencies() {
        return withFinalizeValueOnRead(resolvedDependencies);
    }

    /**
     * <p>The application's dependencies in the format needed by this task. This is a read-only {@link Property} that
     * {@linkplain Configuration#getResolvedConfiguration resolves} the {@link #getDependencies dependencies}
     * configuration when queried, and returns a map that lists the dependency artifact files in classpath order along
     * with their respective {@link Dependency Dependency} objects. Using a {@link Provider} would make more sense
     * semantically, but a {@link Property} allows us to memoize the result.</p>
     */
    @Nonnull
    private final MapProperty<File, Dependency> resolvedDependencies;

    /**
     * Creates an {@link ApplicationJar} task.
     */
    @Inject
    public ApplicationJar() {
        this(null);
        configureApplicationJar();
    }

    /**
     * Creates an {@link ApplicationJar} task without configuring it completely. This constructor is not intended for
     * regular use, it should only be called by other constructors. Once the dependent constructor has made all the
     * {@link Property} objects available, it <b>must</b> call {@link #configureApplicationJar}.
     *
     * @param applicationName The name of the application assembled by this task.
     */
    private ApplicationJar(@Nullable String applicationName) {
        setGroup(ApplicationPlugin.TASK_GROUP);
        setDescription(
                "Assembles " + (applicationName != null ? "the " + applicationName : "an") + " application JAR.");

        resolvedDependencies = getProject().getObjects().mapProperty(File.class, Dependency.class);
    }

    /**
     * Configures this task. Must be called during construction, once all {@link Property} objects are available.
     */
    protected void configureApplicationJar() {
        getDependencyDirectoryName().convention(DEPENDENCY_DIRECTORY_NAME);

        resolvedDependencies
                .value(dependencies().map(this::resolveDependencies).orElse(Collections.emptyMap()))
                .disallowChanges();

        configureArchiveDefaults();
        configureCopyRawJarContents();
        configureEnhanceRawJarManifest();
    }

    @Nonnull
    private Map<File, Dependency> resolveDependencies(@Nonnull Configuration configuration) {
        ResolvedConfiguration resolvedConfiguration = configuration.getResolvedConfiguration();
        Set<File> files = resolvedConfiguration.getFiles();
        Map<File, ModuleVersionIdentifier> fileToId = resolvedConfiguration.getResolvedArtifacts().stream()
                .collect(Collectors.toMap(ResolvedArtifact::getFile, artifact -> artifact.getModuleVersion().getId()));

        // We must retain the iteration order of `files`, and handle local dependencies that have no `ResolvedArtifact`
        Map<File, Dependency> resolvedDependencies = new LinkedHashMap<>(files.size());
        for (File file : files) {
            resolvedDependencies.put(file, new Dependency(file, fileToId.get(file)));
        }
        return Collections.unmodifiableMap(resolvedDependencies);
    }

    /**
     * Configures the default location and name of the {@linkplain #getArchiveFile archive file} created by this task.
     * Unfortunately if we do this in the constructor, where it logically belongs, our settings will be overridden by
     * the {@linkplain TaskCollection#configureEach action} registered in {@link BasePlugin#configureArchiveDefaults}.
     * To counter this, {@link ApplicationPlugin#apply} adds its own {@linkplain TaskCollection#configureEach action}
     * that will subsequently call this method one more time, re-applying our defaults.
     *
     * @see #getArchiveFile()
     * @see #getDestinationDirectory()
     * @see #getArchiveFileName()
     */
    protected void configureArchiveDefaults() {
        // Put application JARs into their own directory to make sure we don't overwrite the raw JARs
        getDestinationDirectory().convention(
                getProject().getLayout().getBuildDirectory().dir(APPLICATION_DIRECTORY_NAME));

        // The most sensible defaults for the archive naming settings would be to copy whatever settings the raw JAR
        // has. However, this quickly becomes problematic for a couple of reasons:
        //  - There may be multiple application JARs based on the same raw JAR. In such a case, our tasks would be
        //    writing to the same output file without any warning to the user. (Note: We face the same issue if we leave
        //    the original defaults intact.)
        //  - The raw JAR may have its `archiveFileName` set to a custom value instead of the normal pattern, but there
        //    is no reliable way to tell whether this is the case. If we copy `archiveFileName`, we lose our own
        //    pattern, and the other archive naming properties of this task (e.g. `archiveBaseName`) will be ignored.
        // Thus, we will:
        //  - Leave the default `archiveFileName` pattern intact
        //  - Keep the defaults for `archiveAppendix`, `archiveVersion`, `archiveClassifier` and `archiveExtension`
        //  - Override the default value of `archiveBaseName` if we can set something that is meaningful and unique
        //    (e.g. in our `Bound` subclass), leave it untouched otherwise
    }

    /**
     * Configures this task to copy the contents of the raw JAR. Called at construction, when properties are not yet
     * set, so everything in here is done lazily through properties and providers.
     */
    private void configureCopyRawJarContents() {
        Provider<FileTree> rawJarTree = rawJar()
                .map(jar -> getProject().zipTree(jar.getArchiveFile()))
                .orElse(getProject().files().getAsFileTree());
        from(rawJarTree);
    }

    /**
     * Configures this task to enhance the manifest of the raw JAR. Called at construction, when properties are not yet
     * set, so everything in here is done lazily through properties and providers.
     */
    private void configureEnhanceRawJarManifest() {
        // Build classpath string
        Provider<String> classpath = resolvedDependencies().map(resolvedDependencies -> {
            String dependencyDirectoryName = dependencyDirectoryName().getOrElse(DEPENDENCY_DIRECTORY_NAME);
            return resolvedDependencies.values().stream()
                    .map(dependency -> dependency.getClasspathEntry(dependencyDirectoryName))
                    .collect(Collectors.joining(" "));
        });

        // Create merged manifest
        List<Provider<Manifest>> baseManifests = new ArrayList<>(2);
        baseManifests.add(rawJar().map(Jar::getManifest).orElse(createManifest(null)));
        baseManifests.add(getProject().getProviders().provider(() -> createManifest(manifest -> {
            manifest.getAttributes().put("Class-Path", classpath.get());
            manifest.getAttributes().put("Main-Class", mainClass()
                    .map(mainClass -> Utils.nonEmpty(mainClass, "mainClass")).getOrElse("Main"));
        })));
        setManifest(new LazyMergeManifest(baseManifests, getManifest()));
    }

    /**
     * Creates a new {@link Manifest}, clears it from any defaults, then configures it with the given action.
     *
     * @param configureAction The action to use to configure the manifest.
     * @return A new manifest configured by the given configuration action.
     */
    @Nonnull
    private Manifest createManifest(@Nullable Action<? super Manifest> configureAction) {
        return getProject().getConvention().getPlugin(JavaPluginConvention.class).manifest(manifest -> {
            clearManifest(manifest);
            if (configureAction != null) {
                configureAction.execute(manifest);
            }
        });
    }

    /**
     * Clears a manifest, so that it can be configured from an empty state. This is important, because when we merge a
     * manifest into another, it will by default overwrite matching entries in the other. By clearing the manifest
     * first, we can be sure that only the entries we specifically added will be merged in.
     *
     * @param manifest The {@link Manifest} to clear.
     * @see org.gradle.api.java.archives.internal.DefaultManifest#clear()
     */
    private void clearManifest(@Nonnull Manifest manifest) {
        manifest.getSections().clear();
        manifest.getAttributes().clear();
    }

    /**
     * Executes this task.
     */
    @Override
    protected void copy() {
        // Only overridden here to make the `@TaskAction` method visible to tests
        super.copy();
    }

    /**
     * <p>Creates a new {@link CopySpec} that can be used to copy the application JAR generated by this task, along with
     * its dependency artifact files, to an organized directory structure that allows the application to be run.</p>
     * <p>The application JAR will be copied to the destination directory, while dependency artifact files will end up
     * in a subdirectory whose name can be set through the {@link #getDependencyDirectoryName dependencyDirectoryName}
     * property. Within that directory, the relative path of dependency artifact files is specified by
     * {@link Dependency#getRelativePath Dependency.relativePath}.</p>
     * <p>Note that in order to avoid resolving the {@link #getDependencies dependencies} configuration too early, the
     * destination paths of dependency artifact files are generated lazily using an {@link CopySpec#eachFile eachFile}
     * action. Since these actions are executed in the order they were registered in, if a custom one gets added to the
     * {@link CopySpec} returned by this method, it will have access to the final destination paths. However, if the
     * returned {@link CopySpec} itself gets added to another one as a {@linkplain CopySpec#with child spec}, and the
     * parent spec has an {@link CopySpec#eachFile eachFile} action of its own, that will <i>not</i> see the final
     * destination paths, because Gradle executes actions registered on the parent spec before those on the child.</p>
     * <p>As a general rule, avoid changing the destination paths or excluding files, because doing so may result in
     * missing dependencies at runtime, causing the application to throw exceptions such as {@link NoClassDefFoundError}
     * or {@link ClassNotFoundException}.</p>
     *
     * @return The new {@link CopySpec}.
     * @see #getDependencyDirectoryName()
     */
    @Nonnull
    public CopySpec applicationCopySpec() {
        return getProject().copySpec(applicationCopy -> {
            applicationCopy.from(this, resolvedDependencies().map(Map::keySet));
            applicationCopy.eachFile(this::modifyDestinationOfDependencyArtifactFile);
            applicationCopy.setDuplicatesStrategy(DuplicatesStrategy.FAIL);
        });
    }

    /**
     * This method gets run as late as possible (when a dependency artifact file is about to be copied), so it can
     * safely evaluate {@link #resolvedDependencies()}.
     */
    private void modifyDestinationOfDependencyArtifactFile(@Nonnull FileCopyDetails copyDetails) {
        Map<File, Dependency> resolvedDependencies = resolvedDependencies().get();
        Dependency dependency = resolvedDependencies.get(copyDetails.getFile());
        if (dependency != null) {
            // Make sure not to lose the directory part of the original relative path: it contains all the path segments
            // contributed by any encompassing specs
            RelativePath relativeDir = Utils.nonNull(copyDetails.getRelativePath().getParent(), "relativeDir");
            copyDetails.setRelativePath(relativeDir
                    .append(false, dependencyDirectoryName().getOrElse(DEPENDENCY_DIRECTORY_NAME))
                    .append(dependency.getRelativePath()));
        }
    }

    @Nonnull
    private <T, P extends HasConfigurableValue & Provider<T>> Provider<T> withFinalizeValueOnRead(@Nonnull P property) {
        return getProject().getProviders().provider(() -> {
            property.finalizeValue();
            return property.getOrNull();
        });
    }

    /**
     * Finalizes the properties of this task. Any further attempts to make changes will result in an
     * {@code IllegalStateException}.
     *
     * @see Property#finalizeValue()
     */
    public void finalizeProperties() {
        Utils.finalizeValues(
                getRawJar(),
                getDependencies(),
                getDependencyDirectoryName(),
                getMainClass(),
                getDestinationDirectory(),
                getArchiveBaseName(),
                getArchiveAppendix(),
                getArchiveVersion(),
                getArchiveClassifier(),
                getArchiveExtension(),
                getArchiveFileName());
    }

    /**
     * An {@link ApplicationJar} task that is bound to an {@link Application}.
     */
    @CacheableTask
    static class Bound extends ApplicationJar {

        /**
         * The {@link Application} that this task is bound to.
         */
        @Nonnull
        private final Application application;

        /**
         * Creates an {@link ApplicationJar.Bound} task.
         *
         * @param application The {@link Application} to bind the task to.
         */
        @Inject
        public Bound(@Nonnull Application application) {
            super(application.getName());
            Utils.argument(application.getProject().equals(getProject()),
                    "Must bind to an application in the same project as this task");
            this.application = application;
            configureApplicationJar();
        }

        @Override
        protected void configureArchiveDefaults() {
            super.configureArchiveDefaults();

            // We can use our application's `applicationBaseName` as our default `archiveBaseName`
            getArchiveBaseName().convention(application.getApplicationBaseName());
        }

        @Nonnull
        @Override
        @GeneratedDelegation
        public Property<Jar> getRawJar() {
            return application.getRawJar();
        }

        @Nonnull
        @Override
        @GeneratedDelegation
        public Property<Configuration> getDependencies() {
            return application.getDependencies();
        }

        @Nonnull
        @Override
        @GeneratedDelegation
        public Property<String> getDependencyDirectoryName() {
            return application.getDependencyDirectoryName();
        }

        @Nonnull
        @Override
        @GeneratedDelegation
        public Property<String> getMainClass() {
            return application.getMainClass();
        }
    }

    /**
     * Contains necessary information about an application dependency.
     */
    private static class Dependency {

        private static final Path BASE_PATH = Paths.get(".");

        @Nonnull
        private final File file;
        @Nullable
        private final String group;

        public Dependency(@Nonnull File file, @Nullable ModuleVersionIdentifier id) {
            this.file = Utils.nonNull(file, "file");
            Utils.nonEmpty(file.getName(), "file.name");
            this.group = (id != null ? Utils.nonEmpty(id.getGroup(), "id.group") : null);
        }

        /**
         * @return Relative path to copy the artifact file of this dependency to (within the application's
         * {@linkplain ApplicationJar#getDependencyDirectoryName dependency directory}).
         */
        @Nonnull
        public RelativePath getRelativePath() {
            RelativePath relativePath = RelativePath.EMPTY_ROOT;
            if (group != null) {
                relativePath = relativePath.append(false, group);
            }
            return relativePath.append(true, file.getName());
        }

        /**
         * @param dependencyDirectoryName Name of the
         * {@linkplain ApplicationJar#getDependencyDirectoryName dependency directory}. Must not be null or empty.
         * @return Relative URL to use as the classpath entry for this dependency.
         * @see <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#classpath">Class-Path</a>
         */
        @Nonnull
        public String getClasspathEntry(@Nonnull String dependencyDirectoryName) {
            Path filePath = BASE_PATH.resolve(Utils.nonEmpty(dependencyDirectoryName, "dependencyDirectoryName"));
            if (group != null) {
                filePath = filePath.resolve(group);
            }
            filePath = filePath.resolve(file.getName());
            // We're creating a relative URI object to escape any special characters (such as spaces)
            return BASE_PATH.toUri().relativize(filePath.toUri()).toString();
        }
    }

    /**
     * A simple delegating {@link Manifest} implementation that supports merging of manifests specified via
     * {@link Provider}s. The {@link Provider}s only get resolved when {@link #getEffectiveManifest} is called.
     */
    private class LazyMergeManifest implements Manifest {

        @Nonnull
        private final List<Provider<Manifest>> baseManifests;
        @Nonnull
        private final Manifest visibleManifest;

        /**
         * Constructor. All underlying manifests have to be specified here, but apart from {@code visibleManifest}, they
         * won't be used until later. Merge behavior (when {@link #getEffectiveManifest} is called):
         * <ol>
         * <li>Create an empty {@link Manifest},</li>
         * <li>Resolve and merge in all {@code baseManifests} in order,</li>
         * <li>Merge in {@code visibleManifest},</li>
         * <li>Call {@link #getEffectiveManifest} on the result.</li>
         * </ol>
         * Entries from latter manifests will overwrite matching ones from former manifests.
         *
         * @param baseManifests List of base manifest {@link Provider}s.
         * @param visibleManifest The visible manifest; this is the manifest that this instance simply delegates most
         * calls to (expect for {@link #getEffectiveManifest}).
         */
        public LazyMergeManifest(@Nonnull List<Provider<Manifest>> baseManifests, @Nonnull Manifest visibleManifest) {
            this.baseManifests = Utils.nonNullElements(baseManifests, "baseManifests");
            this.visibleManifest = Utils.nonNull(visibleManifest, "visibleManifest");
        }

        @Override
        public Manifest getEffectiveManifest() {
            Manifest mergerManifest = createManifest(manifest -> {
                for (Provider<Manifest> baseManifest : baseManifests) {
                    manifest.from(baseManifest.get());
                }
                manifest.from(visibleManifest);
            });
            return mergerManifest.getEffectiveManifest();
        }

        @Override
        @GeneratedDelegation
        public Attributes getAttributes() {
            return visibleManifest.getAttributes();
        }

        @Override
        @GeneratedDelegation
        public Map<String, Attributes> getSections() {
            return visibleManifest.getSections();
        }

        @Override
        @GeneratedDelegation
        public Manifest attributes(Map<String, ?> attributes) throws ManifestException {
            return visibleManifest.attributes(attributes);
        }

        @Override
        @GeneratedDelegation
        public Manifest attributes(Map<String, ?> attributes, String sectionName) throws ManifestException {
            return visibleManifest.attributes(attributes, sectionName);
        }

        @Override
        @GeneratedDelegation
        public Manifest writeTo(Object path) {
            return visibleManifest.writeTo(path);
        }

        @Override
        @GeneratedDelegation
        public Manifest from(Object... mergePath) {
            return visibleManifest.from(mergePath);
        }

        @Override
        @GeneratedDelegation
        public Manifest from(Object mergePath, groovy.lang.Closure<?> closure) {
            return visibleManifest.from(mergePath, closure);
        }

        @Override
        @GeneratedDelegation
        public Manifest from(Object mergePath, Action<ManifestMergeSpec> action) {
            return visibleManifest.from(mergePath, action);
        }
    }
}
